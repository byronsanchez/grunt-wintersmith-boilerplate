/* graph.coffee

  EXPERIMENTAL

  the dependency graph requires harmony proxies to be enabled (node --harmony-proxies)
  i will probably move this to a plugin later
*/


(function() {
  var ContentPlugin, ContentTree, EventEmitter, Graph, GraphHandler, Node, async, buildGraph, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  EventEmitter = require('events').EventEmitter;

  _ref = require('./content'), ContentPlugin = _ref.ContentPlugin, ContentTree = _ref.ContentTree;

  Node = (function() {
    function Node(id, item) {
      this.id = id;
      this.item = item;
      this.edges = [];
    }

    Node.prototype.addEdge = function(node) {
      if (__indexOf.call(this.edges, node) < 0) {
        return this.edges.push(node);
      }
    };

    return Node;

  })();

  Graph = (function() {
    function Graph(identify) {
      this.identify = identify;
      /* *identify* is a function that identifies an item. should return
          a unique string value representing that item.
      */

      this.nodes = {};
    }

    Graph.prototype.addItem = function(item) {
      var id, node;

      id = this.identify(item);
      node = new Node(id, item);
      this.nodes[id] = node;
      return node;
    };

    Graph.prototype.addDependency = function(item, dependency) {
      /* add a *dependency* for *item*
      */

      var node;

      node = this.nodeFor(item);
      return node.addEdge(this.nodeFor(dependency));
    };

    Graph.prototype.dependenciesFor = function(item) {
      /* return a list of items that *item* depends on
      */

      var node, resolved;

      node = this.nodeFor(item);
      resolved = this.resolveNode(node);
      resolved.splice(resolved.indexOf(node), 1);
      return resolved.map(function(node) {
        return node.item;
      });
    };

    Graph.prototype.dependsOn = function(item) {
      /* return a list of items depending on *item*
      */

      var target;

      target = this.nodeFor(item);
      return this.reverseLookup(target).map(function(node) {
        return node.item;
      });
    };

    /* private
    */


    Graph.prototype.nodeFor = function(item) {
      return this.nodes[this.identify(item)] || this.addItem(item);
    };

    Graph.prototype.resolveNode = function(node, resolved, seen) {
      var edge, _i, _len, _ref1;

      if (resolved == null) {
        resolved = [];
      }
      if (seen == null) {
        seen = {};
      }
      seen[node.id] = true;
      _ref1 = node.edges;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        edge = _ref1[_i];
        if (__indexOf.call(resolved, edge) < 0 && !(edge.id in seen)) {
          this.resolveNode(edge, resolved, seen);
        }
      }
      resolved.push(node);
      return resolved;
    };

    Graph.prototype.reverseLookup = function(target) {
      var id, node, rv, _ref1;

      rv = [];
      _ref1 = this.nodes;
      for (id in _ref1) {
        node = _ref1[id];
        if (node === target) {
          continue;
        }
        if (__indexOf.call(this.resolveNode(node), target) >= 0) {
          rv.push(node);
        }
      }
      return rv;
    };

    return Graph;

  })();

  GraphHandler = (function() {
    function GraphHandler(target, fn) {
      this.target = target;
      this.fn = fn;
    }

    GraphHandler.prototype.get = function(receiver, key) {
      var handler, rv;

      rv = this.target[key];
      if (rv instanceof ContentPlugin) {
        this.fn(rv);
        return rv;
      } else if (rv instanceof Object) {
        handler = new GraphHandler(rv, this.fn);
        return Proxy.create(handler, Object.getPrototypeOf(rv));
      } else {
        return rv;
      }
    };

    GraphHandler.prototype.set = function(receiver, key, value) {
      this.target[key] = value;
      return true;
    };

    GraphHandler.prototype.getOwnPropertyNames = function() {
      return Object.getOwnPropertyNames(this.target);
    };

    GraphHandler.prototype.keys = function() {
      return Object.keys(this.target);
    };

    GraphHandler.prototype.enumerate = function() {
      var key, _results;

      _results = [];
      for (key in this.target) {
        _results.push(key);
      }
      return _results;
    };

    GraphHandler.prototype.getPropertyDescriptor = function(key) {
      var desc, obj;

      obj = this.target;
      while (obj) {
        desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc) {
          desc.configurable = true;
          return desc;
        }
        obj = Object.getPrototypeOf(obj);
      }
    };

    GraphHandler.prototype.getOwnPropertyDescriptor = function(key) {
      var desc;

      desc = Object.getOwnPropertyDescriptor(this.target, key);
      if (desc) {
        desc.configurable = true;
      }
      return desc;
    };

    GraphHandler.prototype.defineProperty = function(key, desc) {
      return Object.defineProperty(this.target, key, desc);
    };

    GraphHandler.prototype.has = function(key) {
      return key in this.target;
    };

    GraphHandler.prototype.hasOwn = function(key) {
      return Object.prototype.hasOwnProperty.call(this.target, key);
    };

    GraphHandler.prototype["delete"] = function(key) {
      delete this.target[key];
      return true;
    };

    GraphHandler.prototype.apply = function(receiver, args) {
      return Function.prototype.apply.call(this.target, receiver, args);
    };

    GraphHandler.prototype.construct = function(args) {
      return new Function.prototype.bind.apply(this.target, [null].concat(args));
    };

    return GraphHandler;

  })();

  GraphHandler.proxy = function(tree, fn) {
    var handler;

    handler = new GraphHandler(tree, fn);
    return Proxy.create(handler, ContentTree.prototype);
  };

  buildGraph = function(env, contents, templates, locals, callback) {
    var current, graph, item, items, proxy, _i, _len;

    if (typeof Proxy === "undefined" || Proxy === null) {
      callback(new Error("Harmony proxies not enabled. You need to run node with --harmony-proxies."));
      return;
    }
    current = null;
    items = ContentTree.flatten(contents);
    graph = new Graph(function(item) {
      return item.__filename;
    });
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      graph.addItem(item);
    }
    proxy = GraphHandler.proxy(contents, function(dep) {
      return graph.addDependency(current, dep);
    });
    return async.eachSeries(items, function(item, callback) {
      current = item;
      return item.view(env, locals, proxy, templates, callback);
    }, function(error) {
      return callback(error, graph);
    });
  };

  /* Exports
  */


  module.exports = {
    Graph: Graph,
    GraphHandler: GraphHandler,
    buildGraph: buildGraph
  };

}).call(this);
